pragma solidity 0.4.21;
// WIP
library SafeMath {

  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}

contract ERC20Basic {
  function totalSupply() public view returns (uint256);
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}

contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address => uint256) balances;

  uint256 totalSupply_;

  /**
  * @dev total number of tokens in existence
  */
  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    // SafeMath.sub will throw if there is not enough balance.
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

}

contract Crowdsale {
  using SafeMath for uint256;

  // The token being sold
  ERC20Basic public token;

  // Address where funds are collected
  address public wallet;

  // How many token units a buyer gets per ether
  uint256 public rate;

  // Amount of wei raised
  uint256 public etherRaised;
  
  // Starting point of the ICO
  uint start = now;
  
  modifier FreeExchange{
      require(now >= start + 60 minutes);
      _;
  }

  /**
   * Event for token purchase logging
   * @param purchaser who paid for the tokens
   * @param beneficiary who got the tokens
   * @param value weis paid for purchase
   * @param amount amount of tokens purchased
   */
  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);

  /**
   * @param _wallet Address where collected funds will be forwarded to
   * @param _token Address of the token being sold
   */
  function Crowdsale(address _wallet, ERC20Basic _token) public {
    require(_wallet != address(0));
    require(_token != address(0));

    rate = 1;
    wallet = _wallet;
    token = _token;
  }
  
  // The fallback function calls the buyTokens one, which ensures that whoever transfers funds to the contract gets tokens
  function () external payable {
    buyTokens(msg.sender);
  }

  /**
   * @dev low level token purchase ***DO NOT OVERRIDE***
   * @param _beneficiary Address performing the token purchase
   */
  function buyTokens(address _beneficiary) public payable {
    require(msg.value / 1 ether > 0); //at least 1 ether
    require((msg.value / 1 ether) * 1 ether == msg.value); //accept only round ETH
    
    if(now >= start + 30 minutes && now < start + 60 minutes){
        rate = 2;
    }
    
    uint256 etherAmount = msg.value;
    _preValidatePurchase(_beneficiary, etherAmount);

    // calculate token amount to be created
    uint256 tokens = _getTokenAmount(etherAmount);

    // update state
    etherRaised = etherRaised.add(etherAmount);

    _processPurchase(_beneficiary, tokens);
    emit TokenPurchase(msg.sender, _beneficiary, etherAmount, tokens);

    _forwardFunds();

  }
  
  function transferTokens(uint tokens, address to) public FreeExchange {
        to.transfer(tokens);  
}

  /**
   * @dev Validation of an incoming purchase. Use require statemens to revert state when conditions are not met. Use super to concatenate validations.
   * @param _beneficiary Address performing the token purchase
   * @param _etherAmount Value in wei involved in the purchase
   */
  function _preValidatePurchase(address _beneficiary, uint256 _etherAmount) internal {
    require(_beneficiary != address(0));
    require(_etherAmount != 0);
  }

  /**
   * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.
   * @param _beneficiary Address performing the token purchase
   * @param _tokenAmount Number of tokens to be emitted
   */
  function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {
    token.transfer(_beneficiary, _tokenAmount);
  }

  /**
   * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.
   * @param _beneficiary Address receiving the tokens
   * @param _tokenAmount Number of tokens to be purchased
   */
  function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {
    _deliverTokens(_beneficiary, _tokenAmount);
  }

  /**
   * @dev Override to extend the way in which ether is converted to tokens.
   * @param _etherAmount Value in ether to be converted into tokens
   * @return Number of tokens that can be purchased with the specified _etherAmount
   */
  function _getTokenAmount(uint256 _etherAmount) internal view returns (uint256) {
    return _etherAmount.div(rate);
  }

  /**
   * @dev Determines how ETH is stored/forwarded on purchases.
   */
  function _forwardFunds() internal {
    wallet.transfer(msg.value);
  }
}
